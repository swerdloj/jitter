// NOTE: This file serves as a continuous feature-integration test.
// As new functionality is added to the compiler, this file
// will grow to test that functionality.

// TODO: static, const, @ tags
// TODO: Implement and test out hot-reloading
// @persistent
// static mut TEST: u32 = 0;

// trait Trait {
//     fn test(&self) -> u8;
// }

// TODO: Trait impls
// impl Trait for Test {
//     fn test(&self) -> u8 { 
//         self.a
//     }
// }

// TODO: Type impls
// impl Test {
//     fn add_one(&mut self) {
//         self.a += 1;
//         self.b += 1;
//         self.c += 1;
//     }
// }

// TODO: structs
// fn structs(a: Test) -> Test {
//     let mut test = Test {
//         a: 1,
//         b: 2,
//         c: 3,
//     };

//     test.b = 7;
//     test.add_one();

//     return test;
// }

// TODO: Modules
// use libtest;
// fn module_test() {
//     libtest::pub_test();
// }

struct Test {
    a: i8,
    b: u16,
    c: u16,
}

// TODO: Custom type returns
// fn FFI_test(a: u8, b: u16, c: u16) -> Test {
//     Test { a, b, c }
// }

fn specified_literals() -> i8 {
    Test {
        a: -16_i8 + 3i8,
        b: 123u16 + 7u16,
        c: 3___2_1____u16,
    }.a
}

fn struct_test(a: i8, b: u16, c: u16) -> u16 {
    let x = Test {
        a,
        b,
        c,
    };

    (x.b + x.c) * b
}

// TODO: Tuples
// let y: (i32, u32);

fn multiply(a: i32, b: i32) -> i32 {
    a * b
}

fn negate(a: i32) -> i32 {
    -a
}

// TODO: Infer literal types
// fn return_12i32() -> i32 {
//     return 12;
// }